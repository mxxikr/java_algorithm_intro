## 문자열 섹션 퀴즈
1. 대소문자를 구분하지 않고 문자열 내 특정 문자의 총 개수를 세려면, 어떤 방법이 가장 효율적일까요?
   a. 문자열 전체를 한 가지 케이스(예: 모두 대문자)로 통일한 후 해당 문자의 개수를 센다.
2. Java에서 문자열의 내용을 자주 변경하거나 수정해야 할 때, String 클래스보다 StringBuilder 클래스 사용이 권장되는 주된 이유는 무엇일까요?
   a. String은 문자열 수정 시 매번 새로운 객체를 생성하지만, StringBuilder는 기존 객체 내에서 효율적으로 수정하기 때문이다.
    * String 객체는 Immutable(불변)하기 때문에 내용을 변경하면 새로운 객체가 생성 됨
    * StringBuilder는 mutable(가변)하여 기존 객체 내에서 효율적으로 문자열을 수정할 수 있어 성능에 유리함
3. 문자열에서 알파벳 문자만 순서를 뒤집고, 알파벳이 아닌 특수문자 등은 원래 위치를 그대로 유지하는 알고리즘을 구현할 때 유용하게 사용되는 기법은 무엇일까요?
   a. 문자열을 문자 배열로 변환한 후, 왼쪽(LT)과 오른쪽(RT)에서 시작하는 포인터를 이용하여 양쪽 모두 알파벳일 때만 문자를 교환한다.
    * LT는 앞에서, RT는 뒤에서 시작하며 양쪽 모두 알파벳일 때만 문자를 교환함
    * 알파벳이 아닌 문자를 만나면 해당 포인터만 이동시켜 특수문자는 건너뛰고 위치를 유지할 수 있음
4. 주어진 문자열이 팰린드롬(앞으로 읽으나 뒤로 읽으나 같은 단어)인지 확인할 때, 영어 알파벳과 숫자만 고려하고 대소문자는 무시하려면 어떤 전처리 과정이 필요할까요?
   a. 문자열에서 영어 알파벳과 숫자 외의 모든 문자를 제거하고, 남은 문자열을 모두 대문자 또는 소문자로 통일한다.
    * `replaceAll`과 같은 정규식 함수를 활용하여 필요한 문자(알파벳, 숫자)만 남기고 모두 제거함
    * 대소문자 구분도 함께 처리
5. 공백으로 구분된 문장(예: "This is a test sentence")에서 가장 긴 단어를 찾기 위한 가장 직관적이고 쉬운 접근 방식은 무엇일까요?
   a. split() 메서드를 사용하여 문장을 단어 단위로 분리하여 String 배열에 저장한 후, 배열을 순회하며 각 단어의 길이를 비교한다.
   - `split` 함수는 특정 구분자(여기서는 공백)를 기준으로 문자열을 나누어 String 배열로 반환하는 유용한 기능
   - 배열의 각 요소를 순회하며 길이를 비교하면 가장 긴 단어를 찾을 수 있음
6. 문자열에서 중복된 문자를 제거하되, 처음 등장한 문자의 순서를 그대로 유지하려면 어떻게 해야 할까요?
   a. 각 문자를 순회하며 해당 문자의 indexOf() 결과와 현재 인덱스를 비교하여, 같을 경우에만 결과 문자열에 추가한다.
    * 각 문자의 `indexOf` 결과와 현재 인덱스를 비교하여 처음 등장하는 문자만 결과에 추가함
    * `indexOf`는 해당 문자의 첫 위치를 반환하므로, 현재 위치와 첫 위치가 같을 때만 유효한 문자로 판단함
7. 문자열을 순회하며 '0'부터 '9'까지의 숫자 문자를 발견했을 때, 이들을 순서대로 조합하여 하나의 자연수로 만들기 위해 사용하는 일반적인 방법은 무엇일까요?
   a. 결과 변수에 10을 곱한 후, 현재 발견한 숫자 문자의 값(예: '1'이면 1)을 더한다.
    * 현재까지 만들어진 숫자에 10을 곱하는 것은 자릿수를 하나 올리는 효과를 줌
    * 여기에 새로 발견한 숫자 문자의 값을 더하면 올바른 자연수가 순서대로 형성 됨
8. 문자열 내 각 위치에서 특정 '타겟 문자'까지의 최단 거리를 계산하는 문제에서, 문자열을 왼쪽에서 오른쪽으로 한 번, 오른쪽에서 왼쪽으로 한 번, 총 두 번 순회하며 거리를 계산하는 이유는 무엇일까요?
   a. 왼쪽에 있는 타겟 문자와 오른쪽에 있는 타겟 문자 중 더 가까운 쪽의 거리를 찾기 위해서입니다.
    * 첫 번째 순회로 왼쪽 목표까지의 거리를 기록하고, 두 번째 순회로 오른쪽 목표까지의 거리를 기록함
    * 각 위치에서 두 거리 중 더 작은 값이 최종 최단 거리
9. 연속해서 반복되는 문자를 '문자+반복 횟수' 형태로 압축하는 알고리즘을 구현할 때, 문자열의 가장 마지막에 오는 동일 문자 시퀀스가 누락되지 않고 결과에 포함되도록 처리하는 효과적인 방법은 무엇일까요?
   a. 압축 대상 문자열의 맨 끝에 원본 문자열에 등장하지 않는 임의의 문자를 하나 추가한다.
    * 문자열 끝에 원본에 없는 임의의 문자를 추가하면, 마지막 동일 문자 시퀀스도 반복문 끝에서 처리되어 누락되지 않음
10. '#'은 이진수 1, '*'은 이진수 0을 나타내는 7자리 문자열(예: "#*******")을 해당 ASCII 코드 값을 가지는 대문자 알파벳으로 변환하려면 어떤 과정이 필요할까요?
    a. #을 1로, *을 0으로 치환하여 이진 문자열로 만든 후, Integer.parseInt(이진문자열, 2)를 사용하여 10진수 정수로 변환하고, 그 정수를 char 타입으로 캐스팅한다.
    * `Integer.parseInt` 함수에 이진 문자열과 진수 2를 전달하여 정수로 변환
    * 이렇게 얻은 정수는 ASCII 코드 값이므로, 이를 `char` 타입으로 캐스팅하면 해당 문자를 얻을 수 있음
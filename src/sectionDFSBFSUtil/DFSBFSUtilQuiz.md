## DFS, BFS 활용 섹션 퀴즈
## 배열 섹션 퀴즈
1. DFS를 활용한 부분집합 문제 해결의 핵심 아이디어는 무엇일까요?

   a. 각 원소를 포함하거나 포함하지 않는 두 가지 경로로 분기
    * DFS로 부분집합을 만들 때는 현재 원소를 선택하거나 선택하지 않는 두 가지 경우로 나누어 탐색함
    * 이를 통해 가능한 모든 부분집합을 재귀적으로 생성할 수 있음
2. 부분집합 문제에서 트럭 무게 제한(바둑이 승차)이나 시간 제한(최대점수) 같은 제약 조건을 다룰 때 주로 사용되는 기법은 무엇인가요?

   a. 제약 조건을 초과하면 즉시 탐색 중단 (가지치기)
    * 재귀 탐색(DFS) 중 현재까지의 합이나 값이 제약 조건을 초과하면 더 이상 탐색을 진행할 필요가 없으므로 즉시 해당 경로의 탐색을 중단하여 효율성을 높임
3. DFS를 사용하여 중복 순열과 일반 순열을 생성할 때, 재귀 호출 방식의 주된 차이점은 무엇일까요?

   a. 중복 순열은 각 단계에서 모든 원소를 다시 선택 가능
    * 중복 순열은 이미 사용한 원소도 다시 선택하여 배열에 넣을 수 있으므로, 각 재귀 단계에서 모든 원소를 대상으로 반복문을 돌림
    * 일반 순열은 사용한 원소를 체크하여 제외함
4. DFS로 서로 다른 원소를 사용하여 일반 순열을 생성할 때, '체크(check)' 배열의 주요 목적은 무엇인가요?

   a. 이미 순열에 사용된 원소를 표시
    * 체크 배열은 특정 원소가 현재 만들고 있는 순열에 이미 포함되었는지 여부를 기록함
    * 이를 통해 같은 원소가 중복해서 선택되는 것을 방지함
5. 조합의 경우의 수 (nCk)를 재귀 함수로 계산할 때, 메모이제이션(Memoization) 기법을 사용하는 주된 이유는 무엇일까요?

   a. 이미 계산된 동일한 부 문제의 결과를 재사용하여 성능 향상
    * nCk 계산을 재귀로 하면 같은 n'Ck' 값을 여러 번 계산하게 됨
    * 메모이제이션은 계산된 값을 배열에 저장해두고 필요할 때 가져와 재사용하여 중복 계산을 막고 속도를 높임
6. DFS를 사용하여 서로 다른 원소로 조합을 생성하는 방법이 순열 생성과 근본적으로 다른 점은 무엇인가요? (힌트: 재귀 호출 시 시작 인덱스)

   a. 조합은 이전에 선택한 원소보다 큰 인덱스의 원소만 선택하도록 제한한다
   * 조합은 순서에 상관없이 원소를 선택하므로, 중복을 피하고 사전식 순서로 생성하기 위해 현재 선택한 원소의 다음 인덱스부터 탐색을 시작함
   * 순열은 항상 모든 원소 중에서 선택함
7. 미로 탐색이나 섬 세기 문제처럼 2차원 격자에서 연결된 영역을 탐색할 때, DFS와 BFS 선택의 일반적인 기준은 무엇일까요?

   a. 모든 가능한 경로를 찾거나 연결성 확인 시 DFS, 최단 경로 찾기 시 BFS
   * 일반적으로 DFS는 특정 경로를 깊이 탐색하거나 모든 경로를 찾는 데 사용되며 연결된 모든 곳을 방문하기 좋음
   * BFS는 시작점에서 가까운 곳부터 확장하므로 최단 거리를 찾기에 적합함
8. BFS가 미로 같은 격자에서 최단 경로를 찾는 주된 원리는 무엇인가요?

    a. 시작점에서부터 거리가 1인 모든 지점, 그다음 거리가 2인 모든 지점 순으로 단계별 탐색
    * BFS는 큐를 사용하여 시작점에서부터 거리가 1인 노드들을 모두 방문한 후, 거리가 2인 노드들... 이런 식으로 단계를 확장함
    * 처음 목표 지점에 도달했을 때의 거리가 최단 거리가 됨
9. 토마토 문제처럼 여러 시작 지점(익은 토마토)에서 동시에 확산되는 경우의 BFS는 어떻게 초기화하는 것이 일반적인가요?

   a. 모든 시작 지점을 BFS 시작 전에 큐에 미리 넣어둔다
    * 여러 시작점에서 동시에 확산되는 문제를 BFS로 풀 때는 모든 초기 시작 지점들을 BFS 시작 전에 큐에 넣어둠
    * 이렇게 하면 모든 시작점에서 동시에 탐색이 시작되는 효과를 얻음
10. 피자 배달 거리 문제에서 'M개의 피자집을 선택하여 도시의 최소 배달 거리를 구하는' 방식은 어떤 알고리즘 접근법을 사용하나요?

    a. 가능한 모든 M개 피자집 조합을 생성하고 각 조합별 최소 배달 거리를 계산하여 최솟값 찾기
    * 이 문제는 가능한 모든 '피자집 M개 선택' 경우의 수(조합)를 고려해야 함
    * 각 조합 별로 도시의 총 배달 거리를 계산한 후, 그 결과들 중에서 최솟 값을 찾는 방식으로 해결함
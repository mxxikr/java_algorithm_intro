# 📂 java algorithm intro

김태원 님의 [자바(Java) 알고리즘 문제풀이 입문: 코딩테스트 대비](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-%EC%BD%94%ED%85%8C%EB%8C%80%EB%B9%84/dashboard) 실습 코드 정리

## 💻 Development Environment
* Java 21
* IntelliJ IDEA

## 📝 Curriculum

### Section - String(문자열)
| 핵심 개념 | 설명                                                                                               |
|------|--------------------------------------------------------------------------------------------------|
| **대소문자 통일** | 문자열 비교 시 `toLowerCase()` 또는 `toUpperCase()`로 대소문자 차이를 제거해 일관된 비교 수행                              |
| **String vs StringBuilder** | `String`은 불변(Immutable) → 수정 시 새로운 객체 생성, `StringBuilder`는 가변(Mutable) → 기존 객체 내에서 수정 가능 (성능 유리) |
| **정규표현식을 이용한 전처리** | `replaceAll("[^a-zA-Z0-9]", "")`로 알파벳과 숫자 외 제거 후 대소문자 통일 처리                                      |
| **문자열 분리 (split)** | `split(" ")` 등으로 문자열을 배열로 나눈 뒤, 각 요소(단어)를 순회하며 조건 처리 가능                                          |
| **문자의 첫 등장 위치 판별** | `indexOf(c) == 현재 인덱스`이면 해당 문자는 처음 등장한 문자로 판단 가능                                                 |
| **숫자 조합의 수학 원리** | 자연수 생성 시 기존 숫자에 `* 10`한 뒤 새 숫자를 더해 자릿수 반영                                                        |
| **진수 변환 및 문자 변환** | `#` → 1, `*` → 0 치환 후 → `Integer.parseInt(이진문자열, 2)` → `(char) 정수`로 ASCII 문자 변환                  |

| 패턴 | 설명                                                                  |
|------|---------------------------------------------------------------------|
| **양쪽 포인터(LT/RT)로 문자 교환** | 문자열을 배열로 변환 후, 앞/뒤 포인터를 이용해 알파벳일 때만 swap, 특수문자는 건너뛰고 위치 유지 가능       |
| **양방향 순회로 최단 거리 계산** | 문자열을 왼→오, 오른→왼으로 두 번 순회해 타겟 문자까지의 거리 각각 계산 후 최소값 선택                 |
| **문자열 끝에 더미 문자 추가** | 압축 로직에서 마지막 문자 시퀀스 누락 방지를 위해 원본에 없는 문자(예: 공백) 추가하여 루프에서 마지막 문자까지 처리 |
| **중복 문자 제거 (순서 유지)** | 각 문자 순회 시 `indexOf(c) == 현재 인덱스`인 경우에만 결과 문자열에 추가하여 처음 등장 문자만 유지    |

- [x] 1. 문자 찾기
- [x] 2. 대소문자 변환
- [x] 3. 문장 속 단어(indexOf(), substring())
- [x] 4. 단어 뒤집기(StringBuilder 이용법 또는 직접 뒤집기)
- [x] 5. 특정 문자 뒤집기(toCharArray())
- [x] 6. 중복 문자 제거
- [x] 7. 회문 문자열
- [x] 8. 팰린드롬(replaceAll 정규식 이용)
- [x] 9. 숫자만 추출
- [x] 10. 문자 거리
- [x] 11. 문자열 압축
- [x] 12. 암호(replace(), parseInt(string, 2))

### Section - Array(1, 2차원 배열)
| 핵심 개념 | 설명 |
|-----------|------|
| 최댓값 누적 비교 | 지금까지의 최댓값을 저장하며 현재 값과 비교하는 방식 |
| 조건 기반 비교 | 명확한 규칙을 if문 등 조건문으로 구현하여 비교 판단 |
| 피보나치 수열 생성 | 앞의 두 수를 더하여 다음 항을 만드는 기본 수열 원리 |
| 소수 판별 - 에라토스테네스의 체 | 소수의 배수를 제거하여 남은 수만 소수로 간주하는 방법 |
| 숫자 분해 연산 | `%`로 자릿수 추출, `/`로 숫자 줄여가며 각 자리 처리 |
| 연속 상태 초기화 | 특정 조건(예: 0)을 만나면 누적값 또는 상태를 초기화함 |
| 동점 처리 규칙 | 동점자는 같은 등수, 다음 등수는 동점자 수만큼 건너뜀 |
| 격자에서 최대값 탐색 | 행, 열, 대각선을 개별 계산하여 최대 합 비교 |
| 경계 검사 | 2차원 배열 탐색 시, 인덱스가 배열 범위를 벗어나지 않도록 검사 |
| 멘토링 성립 조건 | 멘토는 모든 시험에서 멘티보다 높은 순위를 가져야 관계 성립 |


| 패턴 | 설명 |
|------|------|
| 한 번의 순회로 조건 추적 | 한 루프 내에서 최댓값이나 상태(점수, 누적 등)를 동시에 갱신 |
| 조건문으로 규칙 처리 | 문제의 규칙을 if-else 또는 switch문으로 간단하게 구현 |
| 누적 변수 활용 | 점수 계산, 연속 성공 등의 문제에서 누적 변수로 흐름 유지 |
| 중첩 반복문 활용 | 2차원 배열을 탐색하거나 두 요소 간 모든 쌍을 비교할 때 사용 |
| 배열 경계 체크 | 2차원 배열 내 이웃 탐색 시 인덱스 유효성 확인 필수 |
| 정렬 또는 등수 계산 알고리즘 | 점수 기반 등수 매기기에서 정렬 또는 직접 순위 비교 사용 |
| 배수 제거 로직 | 소수 판별처럼 특정 조건의 배수 또는 값을 걸러낼 때 반복적으로 제거 |

- [x] 1. 큰 수 출력하기
- [x] 2. 보이는 학생
- [x] 3. 가위바위보
- [x] 4. 피보나치 수열
- [x] 5. 소수(에라토스테네스의 체)
- [x] 6. 뒤집은 소수
- [x] 7. 점수 계산
- [x] 8. 등수 구하기
- [x] 9. 격자판 최대 합
- [x] 10. 봉우리
- [x] 11. 임시 반장 정하기
- [x] 12. 멘토링

### Section - Two pointers, Sliding window [효율성: O(n^2) → O(n)]
| 핵심 개념 | 설명 |
|-----------|------|
| 시간 복잡도 개선 | 투 포인터, 슬라이딩 윈도우는 이중 반복문(O(N²)) 대신 한 번의 선형 탐색(O(N)) 가능 |
| 정렬 상태 활용 | 정렬된 배열에서 두 포인터로 작은 값을 골라 결과 배열에 추가하며 합병 가능 |
| 구간 합 갱신 | 슬라이딩 윈도우 내에서 이동 시, 새로 들어온 값 더하고 빠진 값 빼서 합 갱신 효율화 |
| 합계 조절 | 현재 구간 합이 목표값 초과 시 왼쪽 포인터를 이동시켜 합을 줄임 |
| 제한 조건 유지 | 최대 변경 횟수(k) 초과 시 왼쪽 포인터 이동, 조건을 만족하도록 윈도우 크기 조절 |


| 패턴 | 설명                                             |
|------|------------------------------------------------|
| 두 포인터 병렬 이동 | 두 포인터가 배열을 따로 움직이며 문제 해결                       |
| 슬라이딩 윈도우 합 갱신 | 윈도우가 이동할 때마다 새로운 값 추가, 빠진 값 제거로 합 재계산 최소화      |
| 조건 만족 시 윈도우 확장/축소 | 조건 불만족 시 왼쪽 포인터 이동해 윈도우 크기 조절, 만족 시 오른쪽 포인터 확장 |
| 카운터 변수 사용 | 특정 조건을 세는 변수를 두고 윈도우 내 상태 관리                   |
| 정렬된 배열에서 병합 | 두 배열의 값을 비교하며 결과 배열에 하나씩 추가하는 병합 과정            |


- [x] 1. 두 배열 합치기(two pointers algorithm)
- [x] 2. 공통 원소 구하기(two pointers algorithm)
- [x] 3. 최대 매출(Sliding window)
- [x] 4. 연속 부분 수열(복합적 문제)
- [x] 5. 연속된 자연수의 합(two pointers)
- [x] 6. 연속된 자연수의 합(수학)
- [x] 7. 최대 길이 연속 부분 수열(복합적 문제)

### Section - HashMap, TreeSet (해시, 정렬 지원 Set)

| 핵심 개념 | 설명 |
|-----------|------|
| 기본값 반환 (getOrDefault) | HashMap에서 키가 없으면 지정한 기본값을 반환해 안전하게 값 조회 가능 |
| 아나그램 판별 | 한 단어 문자별 개수를 HashMap에 저장 후, 다른 단어 문자로 감소시켜 모두 0이면 아나그램 |
| 윈도우 요소 관리 | 슬라이딩 윈도우에서 빠져나가는 요소 개수를 HashMap에서 1 감소시켜 상태 유지 |
| 중복 제거 | Set은 중복을 허용하지 않아 유일한 값만 저장하고 관리할 때 효과적 |
| 정렬된 TreeSet | 내림차순 TreeSet에서 first()는 최대값, 오름차순에서는 최소값을 반환 |

| 패턴 | 설명 |
|------|------|
| getOrDefault 활용 | HashMap에서 키 존재 여부 확인 없이 기본값을 지정해 카운팅 등 간단히 처리 |
| 문자 개수 카운팅 | HashMap으로 문자 빈도수를 세고 감소시켜 아나그램, 부분 문자열 문제 해결 |
| 슬라이딩 윈도우와 HashMap | 윈도우 확장 시 개수 증가, 축소 시 개수 감소로 윈도우 내 상태 실시간 유지 |
| Set으로 중복 제거 | 결과 집합에서 중복을 제거할 때 Set을 사용하여 효율적으로 유일 값 관리 |
| TreeSet 정렬 활용 | 정렬된 자료구조를 이용해 최소값, 최대값 빠르게 조회 및 제거 가능 |

- [x] 1. 학급 회장(영상 후반 HashMap 추가 설명)
- [x] 2. 아나그램(HashMap)
- [x] 3. 매출액의 종류(Hash, sliding window)
- [x] 4. 모든 아나그램 찾기(Hash, sliding window: 시간 복잡도 O(n))
- [x] 5. K번째 큰 수(TreeSet 추가 설명)

### Section - Stack, Queue(자료 구조)

| 핵심 개념 | 설명 |
|-----------|------|
| 데이터 처리 순서 차이 | 스택은 LIFO(나중에 들어온 게 먼저 나감), 큐는 FIFO(먼저 들어온 게 먼저 나감) 방식으로 처리 |
| 괄호 짝 검사 | 닫는 괄호를 만났을 때 스택이 비어있으면 유효하지 않은 괄호 순서임 |
| 후위식 계산 | 숫자는 스택에 push하고, 연산자는 스택에서 피연산자 pop하여 계산 |
| 대기열 처리 | 큐는 FIFO 원칙으로 순서대로 항목을 처리하는 시뮬레이션에 적합 |
| 큐 요소 이동 | poll()로 앞에서 꺼내고, offer()로 뒤에 넣어 요소를 앞에서 뒤로 이동 가능 |

| 패턴 | 설명 |
|------|------|
| LIFO와 FIFO 이해 | 문제에 맞게 스택(LIFO) 혹은 큐(FIFO)를 선택하여 효율적 자료 처리 |
| 스택 기반 괄호 유효성 검사 | 여는 괄호는 push, 닫는 괄호는 pop하며 스택 상태로 괄호 쌍 확인 |
| 후위 연산 계산 흐름 | 숫자는 push, 연산자는 pop 2개로 연산 수행 후 결과 push 반복 |
| 큐를 이용한 순차 처리 | 대기열, 작업 순서 처리 시 큐 사용하여 자연스러운 순서 유지 |
| 큐 회전 처리 | 특정 위치까지 poll 후 offer 반복하여 큐 내 순서 조정 |

- [x] 1. 올바른 괄호
- [x] 2. 괄호 문자 제거
- [x] 3. 크레인 인형뽑기
- [x] 4. 후위식 연산(postfix)
- [x] 5. 쇠막대기
- [x] 6. 공주 구하기
- [x] 7. 교육 과정 설계
- [x] 8. 응급실

### Section - Sorting and Searching (정렬, 이분 검색과 결정 알고리즘)

| 핵심 개념 | 설명 |
|-----------|------|
| 버블 정렬 | 인접한 두 요소를 반복 비교하며 위치를 바꾸어 정렬하는 가장 단순한 정렬법 |
| Comparable 인터페이스 | 자바에서 객체의 기본 정렬 기준을 정의하기 위해 compareTo 메서드를 구현하는 인터페이스 |
| 이분 검색 조건 | 이분 검색은 정렬된 데이터에서 중앙값과 목표를 비교하며 탐색 범위를 반씩 줄이는 알고리즘 |
| 결정 알고리즘 원리 | 답이 될 수 있는 범위에서 이분 검색을 통해 조건을 만족하는 최적 값을 찾아내는 탐색 기법 |
| LRU 캐시 동작 | 캐시 적중 시 해당 요소를 배열의 가장 앞으로 옮겨 최근 사용 기록을 갱신함 |

| 패턴 | 설명 |
|------|------|
| 버블 정렬 반복 비교 교환 | 인접 원소를 비교해 조건에 맞게 교환하며 정렬을 완성하는 반복 패턴 |
| Comparable 구현 | 사용자 정의 객체 정렬 시 compareTo 메서드 오버라이딩으로 기준 지정 |
| 이분 검색 수행 | 정렬된 배열에서 중앙 인덱스 기준으로 탐색 범위를 절반씩 축소하며 찾기 |
| 결정 알고리즘 적용 | 답 범위를 정해 이분 탐색으로 조건 검증하며 최적의 해 도출 |
| LRU 캐시 관리 | 적중된 요소를 앞으로 이동시켜 최근 사용 순서 반영하는 배열 조작 |

- [x] 1. 선택 정렬
- [x] 2. 버블 정렬
- [x] 3. 삽입 정렬
- [x] 4. LRU(캐시, 카카오 변형)
- [x] 5. 중복 확인
- [x] 6. 장난꾸러기
- [x] 7. 좌표 정렬(compareTo)
- [x] 8. 이분 검색
- [x] 9. 뮤직비디오(결정 알고리즘)
- [x] 10. 마구간 정하기(결정 알고리즘)

### Section - Recursive, Tree, Graph (DFS, BFS 기초)
- [x] 1. 재귀 함수(스택 프레임)
- [x] 2. 이진수 출력(재귀)
- [x] 3. 팩토리얼
- [x] 4. 피보나치 재귀(메모리제이션)
- [x] 5. 이진 트리 순회(DFS: Depth-First Search)
- [x] 6. 부분 집합 구하기(DFS)
- [x] 7. 이진 트리 레벨 탐색(BFS: Breadth-First Search)
- [x] 8. 송아지 찾기1(BFS)
- [x] 9. 트리 말단 노드까지의 가장 짧은 경로(DFS)
- [x] 10. 트리 말단 노드까지의 가장 짧은 경로(BFS)
- [ ] 11. 그래프와 인접 행렬
- [ ] 12. 경로 탐색(DFS)
- [ ] 13. 경로 탐색(인접 리스트, ArrayList)
- [ ] 14. 그래프 최단 거리(BFS)

### Section - DFS, BFS 활용
- [ ] 1. 합이 같은 부분 집합
- [ ] 2. 바둑이 승차
- [ ] 3. 최대 점수 구하기
- [ ] 4. 중복 순열(채점 지원 안 됨)
- [ ] 5. 동전 교환
- [ ] 6. 순열 구하기(채점 지원 안 됨)
- [ ] 7. 조합 수(메모이제이션)
- [ ] 8. 수열 추측하기
- [ ] 9. 조합 구하기(채점 지원 안 됨)
- [ ] 10. 미로 탐색(DFS)
- [ ] 11. 미로의 최단 거리 통로(BFS)
- [ ] 12. 토마토(BFS)
- [ ] 13. 섬나라 아일랜드(DFS)
- [ ] 14. 섬나라 아일랜드(BFS)
- [ ] 15. 피자 배달 거리(DFS)

### Section - Greedy Algorithm
- [ ] 1. 씨름 선수
- [ ] 2. 회의실 배정
- [ ] 3. 결혼식
- [ ] 4. 최대 수입 스케줄(PriorityQueue)
- [ ] 5. 다익스트라 알고리즘
- [ ] 6. 친구인가(Union & Find 알고리즘)
- [ ] 7. 원더랜드(최소 스패닝 트리 - 크루스칼)
- [ ] 8. 원더랜드(최소 스패닝 트리 - 프림)

### Section - Dynamic Programming(동적 계획법)
- [ ] 1. 계단 오르기
- [ ] 2. 돌다리 건너기
- [ ] 3. 최대 부분 증가 수열(LIS)
- [ ] 4. 가장 높은 탑 쌓기(LIS 응용)
- [ ] 5. 동전 교환(냅색 알고리즘)
- [ ] 6. 최대 점수 구하기(냅색 알고리즘)